function show(x) {
    console.log(typeof(x));    // undefined
    console.log(typeof(10));   // number
    console.log(typeof('abc')); // string
    console.log(typeof(true));  // boolean

    console.log(typeof(function () { }));  //function

    console.log(typeof([1, 'a', true]));  //object
    console.log(typeof ({ a: 10, b: 20 }));  //object
    console.log(typeof (null));  //object
    console.log(typeof (new Number(10)));  //object
}
//function, json, null, new(开头的类似new Array()/new Number()) 返回的是 object

（undefined, number, string, boolean）属于简单的值类型，不是对象。
剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象,他们都是引用类型。

判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。

//判断是否是对象
function isObject(obj){
    if(typeof(obj)=="object" || typeof(obj)=="function"){
       console.log('是对象')
    }else{
       console.log('不是对象')        
    }
}
var str=function(){};
isObject(str)
//对象里面判断具体属于某种类型
console.log([] instanceof Array)
console.log(function(){ } instanceof Function)
console.log(function(){ } instanceof Object)
console.log({} instanceof Object)

一切（引用类型）都是对象，对象是属性的集合。
对象是函数创建的，而函数却又是一种对象
var obj=new Object(); console.log(typeof(obj));//object console.log(typeof(Object));//function

function Fn() { }
Fn.prototype.name = '王福朋';
Fn.prototype.getYear = function () {
    return 1988;
};

var fn = new Fn();
console.log(fn.name);
console.log(fn.getYear());
即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。
因为每个对象都有一个隐藏的属性——“proto”，这个属性引用了创建这个对象的函数的prototype。即：fn.proto === Fn.prototype
这里的"proto"成为“隐式原型”

每个函数function都有一个prototype，即原型
每个对象都有一个__proto__，可成为隐式原型

每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。

对象通过函数创建出来
基本函数的_proto_指向Function.prototype
原始函数Function的__proto__指向了自身的Function.prototype
对象的_proto_指向 Function(){}  Function.prototype  Function.prototype也是一个对象所以_proto_指向Object.prototype
例外是Object.prototype的_proto_指向null

Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。
所以——Function是被自身创建的。所以它的__proto__指向了自身的Prototype。


